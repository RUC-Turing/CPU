# 流水线 MIPS 处理器（10 条）

设计并实现流水线 MIPS 处理器，支持所列举的少部分 MIPS 指令。

## 实验指导

### 指令集

需要支持的指令如下：

* `ADDU` 寄存器加法
* `SUBU` 寄存器减法
* `ORI` 立即数或
* `LW` 对齐加载
* `SW` 对齐存储
* `BEQ` 相等时跳转
* `LUI` 加载立即数到高位
* `JAL` 函数调用
* `JR` 寄存器跳转
* `J` 绝对跳转

其中除最后一条 `j` 指令外，均为上一个实验（单周期）中实现过的。同样，为了方便测试，请识别 `syscall` 指令，并在该指令执行完成后使用 `$finish` 语句结束仿真。

在流水线 CPU 中，我们需要处理分支延迟槽（Branch Delay Slot）。在使用 Mars 工具辅助测试时，请确保 Mars 的[延迟分支](/tools/mars.md#延迟分支)选项已**开启**。

### 流水线

你需要实现五级流水线（IF-ID-EX-MEM-WB），并实现完整的旁路转发。执行同一程序时，你的实现所用时钟周期数与参考实现相比，应当仅相差常数级别。

每一级流水线的计算结果，应当在每个时钟周期结束时，储存在这一级的流水线寄存器中。也就是说，每一时刻，流水线寄存器储存了该级流水线上个周期的结果。此外，为了方便调试和检查，应当额外存储其上个周期**所运行的指令**以及**所处的 PC 值**。

在使用旁路转发处理冲突时，应当转发来自某一级流水线寄存器的值，而非具体元件的值。

建议将控制信号封装为 `struct`，并沿着流水线传递，并将每一级流水线寄存器封装为 `struct`。

!!! warning "警告"
    请牢记阻塞赋值（`=`）与非阻塞赋值（`<=`）的特性，并牢记每个寄存器变量只能在一个时序 `always` / `always_ff` 块中被赋值。

### 测试

为了确保能够检查出所有错误，并方便地定位出错位置，我们记录每次**寄存器写入**与**内存写入**，并将其与 Mars 的标准实现对比。

在写入寄存器时添加如下 `$display` 语句（请将该指令所在的 PC 值传入通用寄存器组件）：

```verilog
if (registerId != 0) // 不输出对 0 号寄存器的写入
    $display("@%h: $%d <= %h", programCounter, registerId, dataWrite);
```

在写入内存时添加如下 `$display` 语句（其中 `address` 为完整的 32 位地址；请将该指令所在的 PC 值传入数据存储器组件）：

```verilog
$display("@%h: *%h <= %h", programCounter, address, dataWrite);
```

仿真运行时，仿真工具的输出中应当含有如下内容：

```plain
@00003000: $31 <= 00003000
@00003004: $ 2 <= 00000000
@00003008: $ 2 <= 00000000
@0000300c: $ 0 <= 00030000
@00003010: $ 0 <= 00000000
@00003014: $ 1 <= 00040000
@00003018: *00000004 <= 00003000
@0000301c: $ 1 <= 00006000
@00003020: *00000008 <= 00003000
@00003024: $ 1 <= 00003000
```

对比你的输出信息与[带有调试信息的 Mars](https://men.ci) 的输出信息，第一次出现的不一致的行即为你的出错位置。
