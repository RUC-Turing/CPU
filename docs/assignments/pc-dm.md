# PC 寄存器与数据存储器

使用 Verilog 编写 PC（Program Counter）寄存器与数据存储器（Data Memory）模块。

## 实验目的

通过编写 CPU 中两个简单的包含时序逻辑的模块，熟悉对时序逻辑电路的设计与调试，体会时序逻辑电路设计与软件设计的区别，并熟悉 CPU 的模块组成。

## 实验指导

CPU 的运行流程以周期（Cycle）划分，在本课程中我们可以简单地理解为时序逻辑电路的时钟周期。在单周期 CPU 中，CPU 在每个时钟周期执行一条指令。由于组合逻辑电路的传播需要时间，所以在**周期内**，我们等待电路中的组合逻辑传播（即等待存取和运算），而在每个**时钟沿**时刻，所有存取/运算类的组合逻辑信号已经全部传播到位，此时我们更新每个模块中寄存器的值，进入下一个周期的执行。

由于我们没有模拟运行数字电路所需的 FPGA 硬件设备，所以在仅进行功能仿真的情况下，我们不需要对时序进行定量分析，仅对时序进行进行定性的设计。

### PC 寄存器

PC（Program Counter）寄存器的作用是，在 CPU 运行时，指明当前正在执行的指令的地址，以便在存储器中读取指令以及在执行特定指令时计算偏移。考虑最简单的情况，PC 拥有一个初始值，并在每个时钟周期自增 4（指令定长为 32 位，内存按字节编址）；而特殊情况下，PC 会受分支指令/跳转指令的影响，接受一个外部传入的值，改变 CPU 执行的指令位置。

!!! info "提示"
    PC 寄存器与通用寄存器（General Registers）不同，它拥有独立的电路，并在 CPU 运行时通过与通用寄存器不同的方式来访问和修改。请不要混淆这两个概念。

在电路开始工作时，其内部的状态（寄存器的值）是不确定的，所以我们需要在电路开始运行时通过一个重置（Reset）信号来将变量赋值为一个确定的值。在这里，我们规定，在 CPU 开始运行时，Reset 信号会**保持一个周期**，请在时钟沿时判断 Reset 信号是否被设置，如果被设置则将 PC 寄存器的值赋值为初始值 `0x00003000`。

!!! warning "警告"
    请不要在时序逻辑中使用 `initial` 语句来初始化寄存器的值。`initial` 无法被编译/综合为实际电路，仅应在测试文件中使用。
    
    每个寄存器变量仅应在一个形如 `always @ (posedge clock)` / `always_ff @ (posedge clock)` 的语句块中被赋值，请勿将更新 PC 值与重置 PC 值的逻辑写到多个 `always` / `always_ff` 块中。
    
    特别地，不要使用 `always @ (*)`（即 `always_comb` 或 `always_latch` 语义）语句对 PC 进行重置，因为寄存器仅可在时钟沿上被赋值。

以下是 PC 寄存器模块接口的参考设计（鼓励自己设计各个模块接口，不必严格遵循本文）：

```verilog
module ProgramCounter(
    // 重置（Reset）信号，设置时表示将 PC 寄存器的状态恢复为初始状态。
    input reset,
    // 时钟信号，请接入全局时钟，并在时钟沿时（如，上升沿时）对寄存器变量赋值。
    input clock,
    // 是否开启跳转，如果该信号被设置，则 jumpInput 生效。
    input jumpEnabled,
    // 跳转输入。当开启跳转时，下个周期的 PC 的值将被设为该值。
    input [31:0] jumpInput,
    // 输出 PC 寄存器的当前值。
    output [31:0] pcValue
);

endmodule
```

### 数据存储器

现代计算机一般采用**冯·诺依曼架构**，即指令与数据存储在统一存储器中。而本次实验为了简化设计，采用**哈弗架构**（现常用于 MCU 中），即指令存储器与数据存储器分离。本次实验要求大家实现数据存储器（Data Memory）模块。

在这里，我们使用一个寄存器数组来模拟数据存储器。读取是一个纯粹的组合逻辑操作，而写入是一个时序逻辑操作。与 PC 寄存器相同，在每个时钟周期结束时，为存储器执行写入操作。与 PC 寄存器相同，我们使用一个重置（Reset）信号来初始化数据存储器的值。

!!! info "提示"
    实践中，考虑到电路的成本和体积，我们往往不使用寄存器数据来实现存储器，而是使用 DRAM。访问 DRAM 的过程较为复杂，并且其延迟远远大于一般 CPU 内部的组合逻辑延迟，所以在实际的计算机中，访问内存往往是 CPU 一条指令执行过程中最耗时的操作。

    本次实验为了降低难度，假设所模拟内存设备延迟极低，在一个周期内即可完成读写，因此不需要特殊考虑。

以下是数据存储器模块接口的参考设计（鼓励自己设计各个模块接口，不必严格遵循本文）：

```verilog
module DataMemory(
    // 重置（Reset）信号，设置时表示将状态恢复为初始状态（全 0）。
    input reset,
    // 时钟信号，请接入全局时钟，并在时钟沿时（如，上升沿时）对寄存器变量赋值。
    input clock,
    // 输入要读取或写入的目标地址。
    input [31:0] address,
    // 是否开启写入，如果该信号被设置，则 writeInput 生效。
    input writeEnabled,
    // 要写入的值。当写入开启时，在时钟沿时向目标地址写入该值。
    input [31:0] writeInput,
    // 输出从目标地址读取到的值。
    output [31:0] readResult
);
    // 用于模拟内存空间的寄存器数组，解释见下文。
    reg [31:0] data [1023:0];

endmodule
```

为了简化，我们在这里规定数据存储器总是以 32 位（4 字节）对齐读写，所以目标地址的最低两位总是 0。推荐将数据存储器实现为 32 位 $\times$ 1024（总共 4 KiB）的寄存器变量（即 `reg [31:0] data [1023:0];`）。并使用目标地址的 `[31:2]` 来访问。

!!! info "提示"
    本次实验中数据存储器的读取操作仅需要使用组合逻辑，不需要使用时序逻辑。请不要使用「将读取结果设为寄存器，并在时钟沿时对其赋值」的方式实验读取操作，这样会导致在时钟沿的前半段，下一个模块无法及时获得该模块的输出。
    
    之后编写的其它模块的输出同理，请保证输出值在当前周期结束的时钟沿**到来前**可用。

## 实验要求

请在编写上述两个模块后，自行设计测试文件进行测试。在测试 PC 寄存器时，请测试自增和跳转两个功能。在测试数据存储器时，请检查是否可以正确读取、写入。
